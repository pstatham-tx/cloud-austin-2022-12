{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction WARNING: This is a work in progress!","title":"Introduction"},{"location":"#introduction","text":"WARNING: This is a work in progress!","title":"Introduction"},{"location":"slides/","text":"Work-in-Progress Observability Primatives Perry Statham pstatham.tx@gmail.com https://www.linkedin.com/in/perrystatham These slides are at: https://github.com/pstatham-tx/cloud-austin-2022-12 My team is currently developing this idea. Suggestions are welcome. Guiding Principle Observing configuration should be managed by those who have the knowledge of what is being observed, regardless of the tools used to observe. But we have ... - Multiple teams in multiple lines of business - Managing multiple services (legacy and green-field) - Multiple clouds (AWS, Azure, GCP, IBM, ...) - Multiple observability tools (Edge Delta, Datadog, Splunk, Dynatrace, CloudWatch, Prometheus, Grafana, ...) What we need is ... A way to specify what to observe and how to observe it -- without being tied to specific tools. Idea: Observability Primitives -- telemetry collection metrics logs traces -- monitors for telemetry conditions to notify about (i.e., alert) when observed passive - watching collected telemetry active - synthetically interacting with an interface -- notification targets - who to notify methods - how to notify (slack, email, pager, ...) schedules - when to use which method and targets process docs (e.g., run-books) - what those notified can do -- schedules maintenance - change expectations; change monitors; ... -- visuals panels - graphics, text, ... dashboards - combinations of panels Example: Metric apiVersion: oca/v1alpha1 kind: metric metadata: name: container.cpu.utilization description: \"Container CPU utilization\" enabled: true spec: unit: 1 gauge: # must be one of (sum, gauge, histogram) value_type: double Example: Monitor apiVersion: monitors/v1alpha1 kind: Rule metadata: name: container.memory.usage.high spec: metrics: container.memory.usage k8s.container.memory_limit oca.core.up expression: (container.memory.usage > 100) AND (k8s.container.memory_limit[labels][id] == container.memory.usage[labels][id]) for: 15m severity: warning annotations: summary: Container {{$labels.container.name}} has been using more than its memory limit for at least 15 minutes. description: | Container: {{ container.memory.usage[labels][name] }} Namespace: {{ container.memory.usage[labels][namespace] }} Environment: {{ oca.core.up[labels][environment] }} Memory Limit: {{ k8s.container.memory_limit }}","title":"Slides"},{"location":"slides/#observability-primatives","text":"Perry Statham pstatham.tx@gmail.com https://www.linkedin.com/in/perrystatham These slides are at: https://github.com/pstatham-tx/cloud-austin-2022-12 My team is currently developing this idea. Suggestions are welcome.","title":"Observability Primatives"},{"location":"slides/#guiding-principle","text":"Observing configuration should be managed by those who have the knowledge of what is being observed, regardless of the tools used to observe.","title":"Guiding Principle"},{"location":"slides/#but-we-have","text":"- Multiple teams in multiple lines of business - Managing multiple services (legacy and green-field) - Multiple clouds (AWS, Azure, GCP, IBM, ...) - Multiple observability tools (Edge Delta, Datadog, Splunk, Dynatrace, CloudWatch, Prometheus, Grafana, ...)","title":"But we have ..."},{"location":"slides/#what-we-need-is","text":"A way to specify what to observe and how to observe it -- without being tied to specific tools.","title":"What we need is ..."},{"location":"slides/#idea-observability-primitives","text":"-- telemetry collection metrics logs traces -- monitors for telemetry conditions to notify about (i.e., alert) when observed passive - watching collected telemetry active - synthetically interacting with an interface -- notification targets - who to notify methods - how to notify (slack, email, pager, ...) schedules - when to use which method and targets process docs (e.g., run-books) - what those notified can do -- schedules maintenance - change expectations; change monitors; ... -- visuals panels - graphics, text, ... dashboards - combinations of panels","title":"Idea: Observability Primitives"},{"location":"slides/#example-metric","text":"apiVersion: oca/v1alpha1 kind: metric metadata: name: container.cpu.utilization description: \"Container CPU utilization\" enabled: true spec: unit: 1 gauge: # must be one of (sum, gauge, histogram) value_type: double","title":"Example: Metric"},{"location":"slides/#example-monitor","text":"apiVersion: monitors/v1alpha1 kind: Rule metadata: name: container.memory.usage.high spec: metrics: container.memory.usage k8s.container.memory_limit oca.core.up expression: (container.memory.usage > 100) AND (k8s.container.memory_limit[labels][id] == container.memory.usage[labels][id]) for: 15m severity: warning annotations: summary: Container {{$labels.container.name}} has been using more than its memory limit for at least 15 minutes. description: | Container: {{ container.memory.usage[labels][name] }} Namespace: {{ container.memory.usage[labels][namespace] }} Environment: {{ oca.core.up[labels][environment] }} Memory Limit: {{ k8s.container.memory_limit }}","title":"Example: Monitor"}]}